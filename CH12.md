## 챕터12 디자인 패턴

디자인 패턴은 반복되는 문제들에 대한 일반적이고 재사용가능한 해결책이다. 객체지향 프로그래밍의 전형적인 특징인 디자인 패턴은 자바와 루비 세계의 많은 이들에게 친숙한 공통된 용어를 제공한다.

다르게 보면, 패턴은 장황함과 되풀이의 원천일 수도 있다. 이 점에 대해서, 폴 그레이엄은 어떤 언어에서 디자인 패턴의 존재와 사용은 문제를 손쉽게 푼 결론이라기 보다 그 언어 자체에 대한 약점을 나타내는 것이라고 평한 바 있다.
    
    내가 내 프로그램에서 패턴을 볼 때, 나는 그것이 문제의 징표라고 생각한다. 프로그램의 형상은 오로지 풀어야 할 문제만을
    반영해야 한다. 코드에 있는 어떤 다른 규칙성도 적어도 나에게는 내가 충분히 강력하지 않은 추상성을 사용하고 있다는 징표이다.
                                                   -- 폴 그레이엄, http://www.paulgraham.com/icad.html

그레이엄은 이것을 알아챈 첫번째 사람은 아니었다. 얼마 전에 피터 노빅은 Lisp이 특히 대부분의 디자인 패턴을 단순화하거나 보이지 않게 만든다고 소개했다.(http://www.novig.com/design-patterns/) 클로저는 이 전통을 지속한다. 일급 함수, 동적 타이핑, 그리고 불변 값들 같은 강력한 생성물 덕분에, 가장 일반적인 디자인 패턴들의 많은 것들이 소멸된다. 그리고, 클로저는 여러분에게 여러분이 스스로 상용구를 만드는 것을 피하는데 필요한 도구들을 매크로와 함께 제공한다.

일반적인 다자인 패턴들을 포괄하는 클로저 코드 예제들은 이 책 전반에 걸쳐 흩어져 있다.

**Listener, Observer.**  일급 함수와 동적 타이핑의 희생량인 이들은 그저 관련된 이벤트가 발생할 때 호출되는 함수들이다. 이런 이벤트는 `176페이지의 "감시"`에 있는 레퍼런스들 타입들에 대한 감시자로 관찰될 수도 있다. 레퍼런스 타입들 이외에, 불변 값의 우선적인 사용은 여러분이 추적할 필요가 있는 가변적인 것들의 범주가 굉장히 최소화된다는 것을 의미한다.

**Abstract Factory, Strategy, Command.**  만약 여러분이 어떤 유형의 기능의 구현체들을 여러개 가지고 있다면--달라지는 타입이나 설정의 값을 생산하던지, 아니면 알고리즘의 변화를 구현하던지 상관없이--FactoryFactory나 여러분의 알고리즘 구현체를 호출하기 위한 맥락을 생산할 필요가 없다. 두 가지 경우 모두, 그냥 다른 함수가 할 것이다.

**Iterator.**  Iterator는 89페이지의 "시퀀스"에서 설명된 시퀀스에 의하여 완전히 포괄된다(be supersetted), 그래서 Iterator는 **map** 같은 함수들을 통하여 적은 노력으로 선언적으로 사용된다. 

**Adapter, Wrapper, Delegate.**  다른 곳에서 이들은 유연하지 않은 타입 계층구조 때문에 필요성이 생기는데, 프로토콜이 이들을 필요없게 만든다. 프로토콜은 여러분이 상속이나 adaptaion이나 래핑에 호소하지 않고도 기존 타입에 새로운 행동을 별도로 정의하게 해준다.

**Memento.** 객체의 가변성 위에 공통된 API를 계층화하는 것은 문제들의 가장 기계적인 부분을 해결하지만(API 일반화), 가변 상태 자체의 두드러진 복잡성을 해결하지는 못한다. 불변 컬렉션과 레코드들은 이 전략을 뒤집었다. 가변 상태는 값에서 제외되고, 그 값들의 이전 버전들을 보관하는 것은 비용이 적게 들고 쉬우며, 상태 변화는 레퍼런스 타입에 남겨 진다.(각각의 레퍼런스 타입은 각각의 동시성과 변화 의미론에 적합한 다른 API를 제공한다.)
<!--Layering a common API over top the mutation of an object solves the most mechanical of problems (API generality), but does nothing to address the glaring complexity of the mutable state itself. Immutable collections and records invert this
strategy: mutable state is barred from values, retaining prior versions of those values is cheap and easy, and state transitions are left to reference types (each of which provides a different API to suit its respective concurrency and change semantics).-->

**Template Method.**  
<!--The limitations of class inheritance are well-known and felt daily by millions, yet it is used widely, often as the sole way to compose functionality within many languages. This dubious mingling of concerns is better recast as a higher-order function that can accept functions implementing the variable behavior while providing a canonical implementation of shared functionality. For example, if we needed to be able to call equivalent HTTP APIs offered by different providers based on some appli-cation-internal data structure, a HOF would allow us to define the provider-specific functionality as a separate function, while keeping the universal HTTP plumbing in one place:-->
